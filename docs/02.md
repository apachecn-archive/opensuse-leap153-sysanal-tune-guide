# 2 系统监控实用程序

> 原文：<https://doc.opensuse.org/documentation/leap/tuning/html/book-tuning/cha-util.html>

###### 摘要

有许多程序、工具和实用程序可以用来检查系统的状态。本章介绍了一些参数，并描述了它们最重要和最常用的参数。

[2.1 多功能工具](cha-util.html#sec-util-multi)

[2.2 系统信息](cha-util.html#sec-util-system)

[2.3 进程](cha-util.html#sec-util-processes)

[2.4 内存](cha-util.html#sec-util-memory)

[2.5 网络](cha-util.html#sec-util-networking)

[2.6 `/proc` 文件系统](cha-util.html#sec-util-proc)

[2.7 硬件消息](cha-util.html#sec-util-hardware)

[2.8 文件和文件系统](cha-util.html#sec-util-file)

[2.9 用户信息](cha-util.html#sec-util-user)

[2.10 时间和日期](cha-util.html#sec-util-time)

[2.11 数据可视化: RRDtool](cha-util.html#sec-util-rrdtool)

对于所描述的每个命令，都提供了相关输出的示例。在示例中，第一行是命令本身(在`tux` >或 root #之后)。省略的用方括号(`[...]`)表示，长的行在必要的地方换行。长行的换行符用反斜杠(`\`)表示。

```sh
> command -x -y
output line 1
output line 2
output line 3 is annoyingly long, so long that \
    we need to break it
output line 4
[...]
output line 98
output line 99
```

描述已经保持简短，以便我们可以包括尽可能多的实用程序。所有命令的更多信息可以在手册页中找到。大多数命令也理解参数`--help`，它产生一个可能参数的简短列表。

## 2.1 多功能工具

虽然大多数 Linux 系统监控工具只监控系统的一个方面，但是有一些工具的监控范围更广。要获得一个概览并找出系统的哪个部分需要进一步检查，首先使用这些工具。

### 2.1.1 `vmstat`

vmstat 收集有关进程、内存、I/O、中断和 CPU 的信息:

```sh
vmstat [options] [delay [count]]
```

当在没有延迟和计数值的情况下调用时，它显示自上次重新启动以来的平均值。当使用延迟值(以秒为单位)调用时，它显示给定时间段的值(在下面的示例中为两秒)。count 的值指定 vmstat 应该执行的更新次数。如果未指定，它将一直运行，直到手动停止。

###### 例 2.1: `vmstat`在轻度使用的机器上输出

```sh
> vmstat 2
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0  44264  81520    424 935736    0    0    12    25   27   34  1  0 98   0  0
 0  0  44264  81552    424 935736    0    0     0     0   38   25  0  0 100  0  0
 0  0  44264  81520    424 935732    0    0     0     0   23   15  0  0 100  0  0
 0  0  44264  81520    424 935732    0    0     0     0   36   24  0  0 100  0  0
 0  0  44264  81552    424 935732    0    0     0     0   51   38  0  0 100  0  0
```

###### 例 2.2: `vmstat`在一台使用率很高的机器上输出(CPU 绑定)

```sh
> vmstat 2
procs -----------memory----------- ---swap-- -----io---- -system-- -----cpu------
 r  b   swpd   free   buff   cache   si   so    bi    bo   in   cs us sy id wa st
32  1  26236 459640 110240 6312648    0    0  9944     2 4552 6597 95  5  0  0  0
23  1  26236 396728 110336 6136224    0    0  9588     0 4468 6273 94  6  0  0  0
35  0  26236 554920 110508 6166508    0    0  7684 27992 4474 4700 95  5  0  0  0
28  0  26236 518184 110516 6039996    0    0 10830     4 4446 4670 94  6  0  0  0
21  5  26236 716468 110684 6074872    0    0  8734 20534 4512 4061 96  4  0  0  0
```

![Tip](img/d61691e7a24e74558ece533d7932dfc0.png "Tip")

###### 提示:输出的第一行

vmstat 输出的第一行总是显示自上次重新启动以来的平均值。

这些列显示以下内容:

r

显示处于可运行状态的进程数量。这些进程要么正在执行，要么正在等待空闲的 CPU 插槽。如果此列中的进程数一直高于可用的 CPU 数，这可能表明 CPU 能力不足。

b

显示等待 CPU 以外的资源的进程数。该列中的高数值可能表示存在 I/O 问题(网络或磁盘)。

swpd

当前使用的交换空间量(KB)。

free

未使用的内存量(KB)。

inact

可以回收的最近未使用的内存。该列仅在使用参数`-a`调用`vmstat`时可见(推荐)。

active

通常不会回收的最近使用的内存。该列仅在使用参数`-a`调用`vmstat`时可见(推荐)。

buff

RAM 中包含文件系统元数据的文件缓冲区缓存(KB)。用参数`-a`调用`vmstat`时，该列不可见。

cache

RAM 中包含文件实际内容的页面缓存(KB)。用参数`-a`调用`vmstat`时，该列不可见。

si / so

每秒从交换移动到 RAM (`si`)或从 RAM 移动到交换(`so`)的数据量(KB)。长时间的高`so`值可能表明应用程序正在泄漏内存，并且泄漏的内存正在被换出。长时间的高`si`值可能意味着长时间处于非活动状态的应用程序现在再次处于活动状态。长时间的组合高`si`和`so`值是交换系统颠簸的证据，并且可能表明需要在系统中安装更多 RAM，因为没有足够的内存来容纳工作集大小。

bi

每秒从块设备接收的块数(例如，磁盘读取)。请注意，交换也会影响此处显示的值。数据块大小可能因文件系统而异，但可以使用 stat 实用程序来确定。如果需要吞吐量数据，则可以使用 iostat。

bo

每秒发送到块设备的块数(例如，磁盘写入)。请注意，交换也会影响此处显示的值。

in

每秒中断数。高值可能表示高 I/O 级别(网络和/或磁盘)，但也可能是由其他原因触发的，例如由另一个活动触发的处理器间中断。确保也检查`/proc/interrupts`以识别中断源。

cs

每秒上下文切换的次数。这是内核将内存中一个程序的可执行代码替换为另一个程序的可执行代码的次数。

us

执行应用程序代码的 CPU 使用百分比。

sy

执行内核代码的 CPU 使用百分比。

id

CPU 空闲时间的百分比。如果该值在较长时间内为零，则您的 CPU 正在满负荷工作。这并不一定是一个不好的迹象——而是参考列 r 和 b 中的值来确定你的机器是否配备了足够的 CPU 能力。

wa

如果`wa`时间不为零，则表明由于等待 I/O 而丢失了吞吐量。这可能是不可避免的，例如，如果是第一次读取文件，后台写回会跟不上，等等。它也可以是硬件瓶颈(网络或硬盘)的指示器。最后，它可以指示调优虚拟内存管理器的可能性(参见第十四章 [*调优内存管理子系统*](cha-tuning-memory.html "Chapter 14. Tuning the memory management subsystem"))。

st

从虚拟机窃取的 CPU 时间的百分比。

更多选项见`vmstat` `--help`。

### 2.1.2 `dstat` 

`dstat`是对`vmstat`、`iostat`、`netstat`或`ifstat`等工具的替代。`dstat`实时显示系统资源信息。例如，您可以结合 IDE 控制器的中断比较磁盘使用情况，或者比较网络带宽和磁盘吞吐量(在相同的时间间隔内)。

默认情况下，其输出显示在可读的表格中。或者，可以生成适合作为电子表格导入格式的 CSV 输出。

它是用 Python 编写的，可以用插件来增强。

这是一般语法:

```sh
dstat [-afv] [*OPTIONS*..] [*DELAY* [*COUNT*]]
```

所有选项和参数都是可选的。不带任何参数，dstat 显示 CPU ( `-c`、`--cpu`)、磁盘(`-d`、`--disk`)、网络(`-n`、`--net`)、分页(`-g`、`--page`)以及系统中断和上下文切换(`-y`、`--sys`)的统计信息；它每秒钟都会刷新一次输出:

```sh
# dstat
You did not select any stats, using -cdngy by default.
----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw
  0   0 100   0   0   0|  15k   44k|   0     0 |   0    82B| 148   194
  0   0 100   0   0   0|   0     0 |5430B  170B|   0     0 | 163   187
  0   0 100   0   0   0|   0     0 |6363B  842B|   0     0 | 196   185
```

`-a`, `--all`等于`-cdngy`(默认)

`-f`, `--full`展开`-C`、`-D`、`-I`、`-N`和`-S`发现列表

`-v`, `--vmstat`等于`-pmgdsc`，`-D total`

*DELAY*

每次更新之间的延迟秒数

*COUNT*

退出前要显示的更新次数

默认延迟为 1，计数未指定(无限制)。

有关更多信息，请参见`dstat`的手册页及其在[http://dag.wieers.com/home-made/dstat/](http://dag.wieers.com/home-made/dstat/)的网页。

### 2.1.3 系统活动信息:`sar`

可以生成几乎所有重要系统活动的详细报告，包括 CPU、内存、IRQ 使用、I/O 和网络。它还可以实时生成报告。`sar`命令从`/proc`文件系统收集数据。

![Note](img/ff87f0b59d655d477bfebbc447e7a566.png "Note")

###### 注意:sysstat 包

`sar`命令是 sysstat 包的一部分。用 YaST 或用`zypper in sysstat`命令安装它。`sysstat.service`默认不启动，必须用以下命令启用和启动:

```sh
> sudo systemctl enable --now sysstat
```

#### 与`sar`生成报表

要实时生成报告，请使用间隔(秒)和计数调用`sar`。要从文件生成报告，使用选项`-f`指定文件名，而不是间隔和计数。如果未指定文件名、间隔和计数，`sar`试图从`/var/log/sa/sa*DD*`生成报告，其中 *DD* 代表当天。这是`sadc`(系统活动数据收集器)写入数据的默认位置。使用多个选项查询多个文件。

```sh
sar 2 10                         # real time report, 10 times every 2 seconds
sar -f ~/reports/sar_2014_07_17  # queries file sar_2014_07_17
sar                              # queries file from today in /var/log/sa/
cd /var/log/sa && \
sar -f sa01 -f sa02              # queries files /var/log/sa/0[12]
```

在下面找到有用的`sar`呼叫示例及其解释。有关各栏含义的详细信息，请参见`sar`的`man (1)`。

![Note](img/ff87f0b59d655d477bfebbc447e7a566.png "Note")

###### 注意:sysstat 在服务停止时进行报告

当`sysstat`服务停止时(例如，在重启或关机期间)，该工具仍然通过自动运行`/usr/lib64/sa/sa1 -S ALL 1 1`命令来收集最后一分钟的统计数据。收集的二进制数据存储在系统活动数据文件中。

##### 2.1.3.1.1 CPU 使用报告:`sar`

当不带选项调用时，`sar`显示关于 CPU 使用情况的基本报告。在多处理器计算机上，汇总了所有 CPU 的结果。使用选项`-P ALL`也可以查看单个 CPU 的统计数据。

```sh
# sar 10 5
Linux 4.4.21-64-default (jupiter)         10/12/16        _x86_64_        (2 CPU)

17:51:29        CPU     %user     %nice   %system   %iowait    %steal     %idle
17:51:39        all     57,93      0,00      9,58      1,01      0,00     31,47
17:51:49        all     32,71      0,00      3,79      0,05      0,00     63,45
17:51:59        all     47,23      0,00      3,66      0,00      0,00     49,11
17:52:09        all     53,33      0,00      4,88      0,05      0,00     41,74
17:52:19        all     56,98      0,00      5,65      0,10      0,00     37,27
Average:        all     49,62      0,00      5,51      0,24      0,00     44,62
```

%iowait 显示 CPU 在等待 I/O 请求时空闲的时间百分比。如果该值在较长时间内明显高于零，则 I/O 系统(网络或硬盘)中存在瓶颈。

##### 2.1.3.1.2 内存使用报告:`sar` `-r`

使用选项`-r`生成系统存储器 RAM 的整体图像:

```sh
# sar -r 10 5
Linux 4.4.21-64-default (jupiter)         10/12/16        _x86_64_        (2 CPU)

17:55:27 kbmemfree kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact kbdirty
17:55:37    104232   1834624    94.62        20   627340  2677656   66.24   802052  828024    1744
17:55:47     98584   1840272    94.92        20   624536  2693936   66.65   808872  826932    2012
17:55:57     87088   1851768    95.51        20   605288  2706392   66.95   827260  821304    1588
17:56:07     86268   1852588    95.55        20   599240  2739224   67.77   829764  820888    3036
17:56:17    104260   1834596    94.62        20   599864  2730688   67.56   811284  821584    3164
Average:     96086   1842770    95.04        20   611254  2709579   67.03   815846  823746    2309
```

列 kbcommit 和 %commit 显示了当前工作负载可能需要的最大内存量(RAM 和交换)的近似值。当 kbcommit 显示以千字节为单位的绝对数字时，%commit 显示百分比。

##### 2.1.3.1.3 寻呼统计报表:`sar` `-B`

使用选项`-B`显示内核分页统计数据。

```sh
# sar -B 10 5
Linux 4.4.21-64-default (jupiter)         10/12/16        _x86_64_        (2 CPU)

18:23:01 pgpgin/s pgpgout/s fault/s majflt/s pgfree/s pgscank/s pgscand/s pgsteal/s %vmeff
18:23:11   366.80     11.60  542.50     1.10  4354.80      0.00      0.00      0.00   0.00
18:23:21     0.00    333.30 1522.40     0.00 18132.40      0.00      0.00      0.00   0.00
18:23:31    47.20    127.40 1048.30     0.10 11887.30      0.00      0.00      0.00   0.00
18:23:41    46.40      2.50  336.10     0.10  7945.00      0.00      0.00      0.00   0.00
18:23:51     0.00    583.70 2037.20     0.00 17731.90      0.00      0.00      0.00   0.00
Average:    92.08    211.70 1097.30     0.26 12010.28      0.00      0.00      0.00   0.00
```

majflt/s (每秒主要故障)列显示从磁盘加载到内存中的页面数量。错误的来源可能是文件访问或错误。有时，许多重大故障是正常的。例如，在应用程序启动时。如果在应用程序的整个生命周期中出现重大故障，这可能表明主内存不足，尤其是在与大量直接扫描( pgscand/s )结合使用的情况下。

%vmeff 列显示扫描的页数( pgscand/s )相对于从主内存缓存或交换缓存( pgsteal/s )中重用的页数。这是对页面回收效率的一种衡量。健康值要么接近 100 (每个换出的非活动页面都被重新使用)，要么为 0 (没有扫描任何页面)。该值不应低于 30 。

##### 2.1.3.1.4 闭塞设备统计报表:`sar` `-d`

使用选项`-d`显示块设备(硬盘、光驱、USB 存储设备等。).确保使用附加选项`-p`(漂亮打印)使开发列可读。

```sh
# sar -d -p 10 5
 Linux 4.4.21-64-default (jupiter)         10/12/16        _x86_64_        (2 CPU)

18:46:09 DEV   tps rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
18:46:19 sda  1.70    33.60      0.00     19.76      0.00      0.47      0.47      0.08
18:46:19 sr0  0.00     0.00      0.00      0.00      0.00      0.00      0.00      0.00

18:46:19 DEV   tps rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
18:46:29 sda  8.60   114.40    518.10     73.55      0.06      7.12      0.93      0.80
18:46:29 sr0  0.00     0.00      0.00      0.00      0.00      0.00      0.00      0.00

18:46:29 DEV   tps rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
18:46:39 sda 40.50  3800.80    454.90    105.08      0.36      8.86      0.69      2.80
18:46:39 sr0  0.00     0.00      0.00      0.00      0.00      0.00      0.00      0.00

18:46:39 DEV   tps rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
18:46:49 sda  1.40     0.00    204.90    146.36      0.00      0.29      0.29      0.04
18:46:49 sr0  0.00     0.00      0.00      0.00      0.00      0.00      0.00      0.00

18:46:49 DEV   tps rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
18:46:59 sda  3.30     0.00    503.80    152.67      0.03      8.12      1.70      0.56
18:46:59 sr0  0.00     0.00      0.00      0.00      0.00      0.00      0.00      0.00

Average: DEV   tps rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
Average: sda 11.10   789.76    336.34    101.45      0.09      8.07      0.77      0.86
Average: sr0  0.00     0.00      0.00      0.00      0.00      0.00      0.00      0.00
```

比较所有磁盘的 tps 、 rd_sec/s 和 wr_sec/s 的平均值。在 svctm 和 %util 列中持续的高值可能表明 I/O 子系统是一个瓶颈。

如果机器使用多个磁盘，那么 I/O 最好在速度和容量相等的磁盘之间均匀交叉。有必要考虑存储是否有多个层。此外，如果有多条存储路径，那么在平衡存储使用方式时，要考虑链路饱和程度。

##### 2.1.3.1.5 网络统计报表:`sar` `-n *KEYWORD*`

选项`-n`允许您生成多个网络相关报告。指定以下关键字之一和`-n`:

*   `DEV`:生成所有网络设备的统计报告

*   `*`:生成所有网络设备的错误统计报告*

*   `**`:为 NFS 客户生成统计报告**

*   `***`:生成 NFS 服务器的统计报告***

*   `****SOCK*`:生成套接字的统计报告***

*   `****`:生成所有网络统计报告**

#### 2.1.3.2 可视化`sar`数据

对于人类来说，报告并不总是容易解析的。kSar 是一个可视化您的`sar`数据的 Java 应用程序，可以创建易读的图表。它甚至可以生成 PDF 报告。kSar 从文件中获取实时生成的数据和过去的数据。kSar 获得 BSD 许可，可从 https://sourceforge.net/projects/ksar(https://sourceforge.net/projects/ksar/) 获得

## 2.2 系统信息

### 2.2.1 装置负荷信息:`iostat`

要监控系统设备负载，使用`iostat`。它生成的报告有助于更好地平衡连接到系统的物理磁盘之间的负载。

为了能够使用`iostat`，安装软件包 sysstat 。

第一个`iostat`报告显示自系统启动以来收集的统计数据。后续报告涵盖自上次报告以来的时间。

```sh
**`>` iostat
Linux 4.4.21-64-default (jupiter)         10/12/16        _x86_64_        (4 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
          17.68    4.49    4.24    0.29    0.00   73.31

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sdb               2.02        36.74        45.73    3544894    4412392
sda               1.05         5.12        13.47     493753    1300276
sdc               0.02         0.14         0.00      13641         37**
```

以这种方式调用`iostat`将有助于您发现吞吐量是否与您的预期不同，但不是为什么。这样的问题可以通过调用`iostat` `-x`生成的扩展报告得到更好的回答。例如，扩展报告还包括平均队列大小和平均等待时间的信息。如果使用`-z`开关排除空闲块设备，评估数据也可能更容易。在`iostat` ( `man 1 iostat`)的手册页中找到每个显示的列标题的定义。

您还可以指定以指定的时间间隔监控某个设备。例如，要为设备`sda`以三秒为间隔生成五份报告，请使用:

```sh
**`>` `iostat` -p sda 3 5**
```

要显示网络文件系统(NFS)的统计数据，有两个类似的实用程序:

*   `nfsiostat-sysstat`包含在 sysstat 软件包中。

*   `nfsiostat`包含在 nfs 客户端包中。

### 2.2.2 处理器活动监控:`mpstat`

实用程序`mpstat`检查每个可用处理器的活动。如果您的系统只有一个处理器，将报告全局平均统计数据。

时序参数的工作方式与`iostat`命令相同。输入`mpstat 2 5`以两秒钟的间隔为所有处理器打印五份报告。

```sh
**`#` mpstat 2 5
Linux 4.4.21-64-default (jupiter)         10/12/16        _x86_64_        (2 CPU)

13:51:10  CPU   %usr  %nice  %sys  %iowait  %irq  %soft  %steal  %guest  %gnice   %idle
13:51:12  all   8,27   0,00  0,50     0,00  0,00   0,00    0,00    0,00    0,00   91,23
13:51:14  all  46,62   0,00  3,01     0,00  0,00   0,25    0,00    0,00    0,00   50,13
13:51:16  all  54,71   0,00  3,82     0,00  0,00   0,51    0,00    0,00    0,00   40,97
13:51:18  all  78,77   0,00  5,12     0,00  0,00   0,77    0,00    0,00    0,00   15,35
13:51:20  all  51,65   0,00  4,30     0,00  0,00   0,51    0,00    0,00    0,00   43,54
Average:  all  47,85   0,00  3,34     0,00  0,00   0,40    0,00    0,00    0,00   48,41**
```

从`mpstat`数据中，可以看到:

* %usr 和 %sys 之间的比率。例如，10:1 的比率表示工作负载主要运行应用程序代码，分析应集中在应用程序上。1:10 的比率表明工作负载主要受内核限制，值得考虑调整内核。或者，确定应用程序受内核限制的原因，看看是否可以缓解这种情况。

* 即使系统总体负载较轻，是否有一部分 CPU 几乎得到了充分利用。很少有热 CPU 能够表明工作负载没有被并行化，并且可以从具有少量更快处理器的机器上执行中受益。

### 2.2.3 处理器频率监控:`turbostat`

`turbostat`显示 AMD64/Intel 64 处理器的频率、负载、温度和功率。它可以在两种模式下运行:如果用命令调用，命令进程被分叉，命令完成时显示统计信息。在没有命令的情况下运行时，它将每五秒钟显示一次更新的统计数据。注意`turbostat`需要加载内核模块`msr`。

```sh
**`>` `sudo` turbostat find /etc -type d -exec true {} \;
0.546880 sec
     CPU Avg_MHz   Busy% Bzy_MHz TSC_MHz
       -     416   28.43    1465    3215
       0     631   37.29    1691    3215
       1     416   27.14    1534    3215
       2     270   24.30    1113    3215
       3     406   26.57    1530    3214
       4     505   32.46    1556    3214
       5     270   22.79    1184    3214**
```

输出取决于 CPU 类型，可能会有所不同。要显示更多细节，如温度和功率，使用`--debug`选项。有关更多命令行选项和字段描述的解释，请参考`man 8 turbostat`。

### 2.2.4 任务监控:`pidstat`

如果您需要查看某个特定任务适用于您的系统的负载，请使用`pidstat`命令。如果没有指定任务，它将打印每个选定任务或 Linux 内核管理的所有任务的活动。您还可以设置要显示的报告数量以及报告之间的时间间隔。

例如，`pidstat` `-C` firefox 2 3 打印命令名包含字符串 " firefox " 的任务的负载统计。每隔两秒钟打印三份报告。

```sh
**`#` pidstat -C firefox 2 3
Linux 4.4.21-64-default (jupiter)         10/12/16        _x86_64_        (2 CPU)

14:09:11      UID       PID    %usr %system  %guest    %CPU   CPU  Command
14:09:13     1000       387   22,77    0,99    0,00   23,76     1  firefox

14:09:13      UID       PID    %usr %system  %guest    %CPU   CPU  Command
14:09:15     1000       387   46,50    3,00    0,00   49,50     1  firefox

14:09:15      UID       PID    %usr %system  %guest    %CPU   CPU  Command
14:09:17     1000       387   60,50    7,00    0,00   67,50     1  firefox

Average:      UID       PID    %usr %system  %guest    %CPU   CPU  Command
Average:     1000       387   43,19    3,65    0,00   46,84     -  firefox**
```

类似地，`pidstat` `-d`可以用来估计有多少 I/O 任务正在执行，它们是否在那个 I/O 上休眠，以及任务被停止了多少个时钟周期。

### 2.2.5 内核环形缓冲:`dmesg`

Linux 内核将某些消息保存在一个环形缓冲区中。要查看这些消息，请输入命令`dmesg -T`。

旧事件记录在`systemd`日志中。参见书 *参考文献* *第 11 章* `journalctl`:查询`systemd`日志了解更多关于日志的信息。

### 2.2.6 打开文件列表:`lsof`

要查看为进程 ID 为 PID 为*的进程打开的所有文件的列表，请使用`-p`。例如，要查看当前 shell 使用的所有文件，请输入:

```sh
**`#` lsof -p $$
COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF  NODE NAME
bash    8842 root  cwd    DIR   0,32      222  6772 /root
bash    8842 root  rtd    DIR   0,32      166   256 /
bash    8842 root  txt    REG   0,32   656584 31066 /bin/bash
bash    8842 root  mem    REG   0,32  1978832 22993 /lib64/libc-2.19.so
[...]
bash    8842 root    2u   CHR  136,2      0t0     5 /dev/pts/2
bash    8842 root  255u   CHR  136,2      0t0     5 /dev/pts/2**
```

已经使用了特殊的 shell 变量`$$`，其值是 shell 的进程 ID。

当与`-i`、`lsof`一起使用时，还会列出当前打开的互联网文件:

```sh
**`#` lsof -i
COMMAND    PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
wickedd-d  917 root    8u  IPv4  16627      0t0  UDP *:bootpc
wickedd-d  918 root    8u  IPv6  20752      0t0  UDP [fe80::5054:ff:fe72:5ead]:dhcpv6-client
sshd      3152 root    3u  IPv4  18618      0t0  TCP *:ssh (LISTEN)
sshd      3152 root    4u  IPv6  18620      0t0  TCP *:ssh (LISTEN)
master    4746 root   13u  IPv4  20588      0t0  TCP localhost:smtp (LISTEN)
master    4746 root   14u  IPv6  20589      0t0  TCP localhost:smtp (LISTEN)
sshd      8837 root    5u  IPv4 293709      0t0  TCP jupiter.suse.de:ssh->venus.suse.de:33619 (ESTABLISHED)
sshd      8837 root    9u  IPv6 294830      0t0  TCP localhost:x11 (LISTEN)
sshd      8837 root   10u  IPv4 294831      0t0  TCP localhost:x11 (LISTEN)**
```

### 2.2.7 内核和 udev 事件序列查看器:`udevadm monitor`

`udevadm monitor`监听内核事件和 udev 规则发出的事件，并将事件的设备路径(DEVPATH)打印到控制台。这是连接 USB 记忆棒时的一系列事件:

**![Note](img/ff87f0b59d655d477bfebbc447e7a566.png "Note")

###### 注:监测 udev 事件

只允许 root 用户通过运行`udevadm`命令来监控 udev 事件。

```sh
**UEVENT[1138806687] add@/devices/pci0000:00/0000:00:1d.7/usb4/4-2/4-2.2
UEVENT[1138806687] add@/devices/pci0000:00/0000:00:1d.7/usb4/4-2/4-2.2/4-2.2
UEVENT[1138806687] add@/class/scsi_host/host4
UEVENT[1138806687] add@/class/usb_device/usbdev4.10
UDEV  [1138806687] add@/devices/pci0000:00/0000:00:1d.7/usb4/4-2/4-2.2
UDEV  [1138806687] add@/devices/pci0000:00/0000:00:1d.7/usb4/4-2/4-2.2/4-2.2
UDEV  [1138806687] add@/class/scsi_host/host4
UDEV  [1138806687] add@/class/usb_device/usbdev4.10
UEVENT[1138806692] add@/devices/pci0000:00/0000:00:1d.7/usb4/4-2/4-2.2/4-2.2
UEVENT[1138806692] add@/block/sdb
UEVENT[1138806692] add@/class/scsi_generic/sg1
UEVENT[1138806692] add@/class/scsi_device/4:0:0:0
UDEV  [1138806693] add@/devices/pci0000:00/0000:00:1d.7/usb4/4-2/4-2.2/4-2.2
UDEV  [1138806693] add@/class/scsi_generic/sg1
UDEV  [1138806693] add@/class/scsi_device/4:0:0:0
UDEV  [1138806693] add@/block/sdb
UEVENT[1138806694] add@/block/sdb/sdb1
UDEV  [1138806694] add@/block/sdb/sdb1
UEVENT[1138806694] mount@/block/sdb/sdb1
UEVENT[1138806697] umount@/block/sdb/sdb1**
```

## 2.3 流程

### 2.3.1 进程间通信:`ipcs`

命令`ipcs`生成当前正在使用的 IPC 资源列表:

```sh
**`#` ipcs
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status
0x00000000 65536      tux        600        524288     2          dest
0x00000000 98305      tux        600        4194304    2          dest
0x00000000 884738     root       600        524288     2          dest
0x00000000 786435     tux        600        4194304    2          dest
0x00000000 12058628   tux        600        524288     2          dest
0x00000000 917509     root       600        524288     2          dest
0x00000000 12353542   tux        600        196608     2          dest
0x00000000 12451847   tux        600        524288     2          dest
0x00000000 11567114   root       600        262144     1          dest
0x00000000 10911763   tux        600        2097152    2          dest
0x00000000 11665429   root       600        2336768    2          dest
0x00000000 11698198   root       600        196608     2          dest
0x00000000 11730967   root       600        524288     2          dest

------ Semaphore Arrays --------
key        semid      owner      perms      nsems
0xa12e0919 32768      tux        666        2**
```

### 2.3.2 流程列表:`ps`

命令`ps`产生一个进程列表。大多数参数必须不带负号。参考`ps --help`获得简要帮助，或参考手册页获得详细帮助。

要列出所有带有用户和命令行信息的进程，请使用`ps axu`:

```sh
**`>` ps axu
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.3  34376  4608 ?        Ss   Jul24   0:02 /usr/lib/systemd/systemd
root         2  0.0  0.0      0     0 ?        S    Jul24   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        S    Jul24   0:00 [ksoftirqd/0]
root         5  0.0  0.0      0     0 ?        S<   Jul24   0:00 [kworker/0:0H]
root         6  0.0  0.0      0     0 ?        S    Jul24   0:00 [kworker/u2:0]
root         7  0.0  0.0      0     0 ?        S    Jul24   0:00 [migration/0]
[...]
tux      12583  0.0  0.1 185980  2720 ?        Sl   10:12   0:00 /usr/lib/gvfs/gvfs-mtp-volume-monitor
tux      12587  0.0  0.1 198132  3044 ?        Sl   10:12   0:00 /usr/lib/gvfs/gvfs-gphoto2-volume-monitor
tux      12591  0.0  0.1 181940  2700 ?        Sl   10:12   0:00 /usr/lib/gvfs/gvfs-goa-volume-monitor
tux      12594  8.1 10.6 1418216 163564 ?      Sl   10:12   0:03 /usr/bin/gnome-shell
tux      12600  0.0  0.3 393448  5972 ?        Sl   10:12   0:00 /usr/lib/gnome-settings-daemon-3.0/gsd-printer
tux      12625  0.0  0.6 227776 10112 ?        Sl   10:12   0:00 /usr/lib/gnome-control-center-search-provider
tux      12626  0.5  1.5 890972 23540 ?        Sl   10:12   0:00 /usr/bin/nautilus --no-default-window
[...]**
```

要检查有多少个`sshd`进程正在运行，使用选项`-p`和命令`pidof`，该命令列出了给定进程的进程 id。

```sh
**`>` ps -p $(pidof sshd)
  PID TTY      STAT   TIME COMMAND
 1545 ?        Ss     0:00 /usr/sbin/sshd -D
 4608 ?        Ss     0:00 sshd: root@pts/0**
```

过程列表可以根据您的需要进行格式化。选项`L`返回所有关键字的列表。输入以下命令，发出按内存使用情况排序的所有进程的列表:

```sh
**`>` ps ax --format pid,rss,cmd --sort rss
  PID   RSS CMD
  PID   RSS CMD
    2     0 [kthreadd]
    3     0 [ksoftirqd/0]
    4     0 [kworker/0:0]
    5     0 [kworker/0:0H]
    6     0 [kworker/u2:0]
    7     0 [migration/0]
    8     0 [rcu_bh]
[...]
12518 22996 /usr/lib/gnome-settings-daemon-3.0/gnome-settings-daemon
12626 23540 /usr/bin/nautilus --no-default-window
12305 32188 /usr/bin/Xorg :0 -background none -verbose
12594 164900 /usr/bin/gnome-shell**
```

###### 有用的`ps`通话

`ps aux``--sort *COLUMN*`

按 *列* 对输出进行排序。将 *列* 替换为

`pmem`为物理内存比
`pcpu`为 CPU 比率
`rss`常驻集大小(非交换物理内存)

`ps axo pid,%cpu,rss,vsz,args,wchan`

显示每个进程、它们的 PID、CPU 使用率、内存大小(常驻和虚拟)、名称以及它们的系统调用。

`ps axfo pid,args`

显示流程树。

### 2.3.3 流程树:`pstree`

命令`pstree`以树的形式生成一个进程列表:

```sh
**`>` pstree
systemd---accounts-daemon---{gdbus}
        |                 |-{gmain}
        |-at-spi-bus-laun---dbus-daemon
        |                 |-{dconf worker}
        |                 |-{gdbus}
        |                 |-{gmain}
        |-at-spi2-registr---{gdbus}
        |-cron
        |-2*[dbus-daemon]
        |-dbus-launch
        |-dconf-service---{gdbus}
        |               |-{gmain}
        |-gconfd-2
        |-gdm---gdm-simple-slav---Xorg
        |     |                 |-gdm-session-wor---gnome-session---gnome-setti+
        |     |                 |                 |               |-gnome-shell+++
        |     |                 |                 |               |-{dconf work+
        |     |                 |                 |               |-{gdbus}
        |     |                 |                 |               |-{gmain}
        |     |                 |                 |-{gdbus}
        |     |                 |                 |-{gmain}
        |     |                 |-{gdbus}
        |     |                 |-{gmain}
        |     |-{gdbus}
        |     |-{gmain}
[...]**
```

参数`-p`将进程 ID 添加到给定的名称中。要显示命令行，请使用`-a`参数:

### 2.3.4 工序表:`top`

命令`top`("进程表")显示每两秒刷新一次的进程列表。要终止程序，按下 Q 。参数`-n 1`在单次显示工艺列表后终止程序。下面是命令`top -n 1`的输出示例:

```sh
**`>` top -n 1
Tasks: 128 total,   1 running, 127 sleeping,   0 stopped,   0 zombie
%Cpu(s):  2.4 us,  1.2 sy,  0.0 ni, 96.3 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem:   1535508 total,   699948 used,   835560 free,      880 buffers
KiB Swap:  1541116 total,        0 used,  1541116 free.   377000 cached Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    1 root      20   0  116292   4660   2028 S 0.000 0.303   0:04.45 systemd
    2 root      20   0       0      0      0 S 0.000 0.000   0:00.00 kthreadd
    3 root      20   0       0      0      0 S 0.000 0.000   0:00.07 ksoftirqd+
    5 root       0 -20       0      0      0 S 0.000 0.000   0:00.00 kworker/0+
    6 root      20   0       0      0      0 S 0.000 0.000   0:00.00 kworker/u+
    7 root      rt   0       0      0      0 S 0.000 0.000   0:00.00 migration+
    8 root      20   0       0      0      0 S 0.000 0.000   0:00.00 rcu_bh
    9 root      20   0       0      0      0 S 0.000 0.000   0:00.24 rcu_sched
   10 root      rt   0       0      0      0 S 0.000 0.000   0:00.01 watchdog/0
   11 root       0 -20       0      0      0 S 0.000 0.000   0:00.00 khelper
   12 root      20   0       0      0      0 S 0.000 0.000   0:00.00 kdevtmpfs
   13 root       0 -20       0      0      0 S 0.000 0.000   0:00.00 netns
   14 root       0 -20       0      0      0 S 0.000 0.000   0:00.00 writeback
   15 root       0 -20       0      0      0 S 0.000 0.000   0:00.00 kintegrit+
   16 root       0 -20       0      0      0 S 0.000 0.000   0:00.00 bioset
   17 root       0 -20       0      0      0 S 0.000 0.000   0:00.00 crypto
   18 root       0 -20       0      0      0 S 0.000 0.000   0:00.00 kblockd**
```

默认情况下，输出按照 CPU 使用率排序(列 %CPU ，快捷方式 Shift–P)。使用以下组合键更改排序字段:

| Shift–M:常驻内存( RES ) |
| Shift–N:进程 ID ( PID ) |
| Shift–T:Time(Time+) |

要使用任何其他字段进行排序，按下 F 并从列表中选择一个字段。要切换排序顺序，请使用 Shift–R。

参数`-U *UID*`仅监控与特定用户相关的进程。用用户的用户 ID 替换 *UID* 。使用`top -U $(id -u)`显示当前用户的进程

### 2.3.5 `iotop`实用程序显示了进程或线程的 I/O 使用情况表。

**![Note](img/ff87f0b59d655d477bfebbc447e7a566.png "Note")

###### 注意:安装`iotop`

默认情况下不安装`iotop`。你需要用`zypper in iotop`作为`root`手动安装。** 

`iotop`显示采样期间每个进程读写的 I/O 带宽的列。它还显示了进程换入和等待 I/O 所花费的时间百分比。对于每个进程，都会显示其 I/O 优先级(类别/级别)。此外，采样期间读写的总 I/O 带宽显示在界面顶部。

*   ← 和 → 键改变排序。

*   R 反转排序顺序。

*   O 在显示所有进程和线程(默认视图)和只显示那些执行 I/O 的进程和线程之间切换。(这个功能类似于在命令行添加`--only`。)

*   P 在显示线程(默认视图)和进程之间切换。(该功能类似于`--only`。)

*   A 在显示当前 I/O 带宽(默认视图)和自`iotop`启动以来的累计 I/O 操作之间切换。(这个功能类似于`--accumulated`.)

*   让你改变一个线程或者一个进程的线程的优先级。

*   问退出`iotop`。

*   按任何其他键将强制刷新。

当`find`和`emacs`运行时，命令`iotop --only`的输出示例如下:

```sh
**`#` iotop --only
Total DISK READ: 50.61 K/s | Total DISK WRITE: 11.68 K/s
  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND
 3416 be/4 tux         50.61 K/s    0.00 B/s  0.00 %  4.05 % find /
  275 be/3 root        0.00 B/s    3.89 K/s  0.00 %  2.34 % [jbd2/sda2-8]
 5055 be/4 tux          0.00 B/s    3.89 K/s  0.00 %  0.04 % emacs**
```

`iotop`也可用于批处理模式(`-b`)，其输出存储在一个文件中供以后分析。有关完整的选项集，请参见手册页(`man 8 iotop`)。

### 2.3.6 修改流程的精细度:`nice``renice`

内核通过进程的 nice 级别(也称为 niceness)来确定哪些进程比其他进程需要更多的 CPU 时间。一个进程的【尼斯】级别越高，它从其他进程那里占用的 CPU 时间就越少。尼斯等级从-20(最少尼斯等级)到 19。负值只能通过`root`设置。

当运行持续时间长且使用大量 CPU 时间的非时间关键型进程时，调整 niceness 级别非常有用。例如，在还执行其他任务的系统上编译内核。使这样的进程 " 更好 " ，确保了其他任务，例如 Web 服务器，将具有更高的优先级。

不带任何参数调用`nice`打印当前的 nice:

```sh
**`>` nice
0**
```

运行`nice` *命令* 将给定命令的当前 nice 等级增加 10。使用`nice` `-n *LEVEL*` *命令* 可以指定一个相对于当前的新精度。

要改变正在运行的进程的精细度，使用`renice` *优先级* `-p *PROCESS_ID*`，例如:

```sh
**`>` renice +5 3266**
```

要重新检查特定用户拥有的所有过程，使用选项`-u *USER*`。过程组由选项`-g *PROCESS_GROUP_ID*`重新命名。

## 2.4 记忆

### 2.4.1 内存使用:`free`

实用程序`free`检查 RAM 和交换空间的使用情况。显示了空闲和已用内存和交换区的详细信息:

```sh
**`>` free
             total       used       free     shared    buffers     cached
Mem:      32900500   32703448     197052          0     255668    5787364
-/+ buffers/cache:   26660416    6240084
Swap:      2046972     304680    1742292**
```

选项`-b`、`-k`、`-m`、`-g`分别以字节、KB、MB 或 GB 显示输出。参数`-s delay`确保显示每隔 *延迟* 秒刷新一次。例如，`free -s 1.5`每 1.5 秒更新一次。

### 2.4.2 详细内存使用:`/proc/meminfo`

使用`/proc/meminfo`获得比使用`free`更详细的内存使用信息。实际上`free`使用了这个文件中的一些数据。请参见下面 64 位系统的输出示例。请注意，由于内存管理不同，它在 32 位系统上略有不同:

```sh
**MemTotal:        1942636 kB
MemFree:         1294352 kB
MemAvailable:    1458744 kB
Buffers:             876 kB
Cached:           278476 kB
SwapCached:            0 kB
Active:           368328 kB
Inactive:         199368 kB
Active(anon):     288968 kB
Inactive(anon):    10568 kB
Active(file):      79360 kB
Inactive(file):   188800 kB
Unevictable:          80 kB
Mlocked:              80 kB
SwapTotal:       2103292 kB
SwapFree:        2103292 kB
Dirty:                44 kB
Writeback:             0 kB
AnonPages:        288592 kB
Mapped:            70444 kB
Shmem:             11192 kB
Slab:              40916 kB
SReclaimable:      17712 kB
SUnreclaim:        23204 kB
KernelStack:        2000 kB
PageTables:        10996 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:     3074608 kB
Committed_AS:    1407208 kB
VmallocTotal:   34359738367 kB
VmallocUsed:      145996 kB
VmallocChunk:   34359588844 kB
HardwareCorrupted:     0 kB
AnonHugePages:     86016 kB
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB
DirectMap4k:       79744 kB
DirectMap2M:     2017280 kB**
```

这些条目代表以下内容:

MemTotal:RAM 的总量

MemFree:未使用的内存量。

MemAvailable:估计在不交换的情况下有多少内存可用于启动新的应用程序。

Buffers: RAM 中包含文件系统元数据的文件缓冲区缓存。

Cached: RAM 中的页面缓存。这不包括缓冲区缓存和交换缓存，但包括 Shmem 内存。

SwapCached:换出内存的页面缓存。

Active, Active(anon), Active(file): 除非必要或明确请求，否则不会回收的最近使用的内存。活跃是活跃(anon) 和活跃(file) 之和:

*   Active(anon) 跟踪交换支持的内存。这包括私有和共享匿名映射以及写入时复制后的私有文件页面。**

*   Active(file) 跟踪其他文件系统支持的内存。

Inactive, Inactive(anon), Inactive(file):通常首先回收的最近较少使用的内存。未激活是未激活(anon) 和未激活(file) 之和:**

*   Inactive(anon) 跟踪交换备份内存。这包括私有和共享匿名映射以及写入时复制后的私有文件页面。

*   Inactive(file) 跟踪其他文件系统支持的内存。

Unevictable:无法回收的内存量(例如，因为它被 m 锁定或用作 RAM 磁盘)。**

Mlocked:由`mlock`系统调用支持的内存量。`mlock`允许进程定义它们的虚拟内存应该映射到物理 RAM 的哪个部分。然而，`mlock`并不保证这种安置。

SwapTotal:交换空间的数量。

SwapFree:未使用的交换空间量.

Dirty:等待写入磁盘的内存量，因为它包含与后备存储相比的更改。短时间延迟后，应用程序或内核可以显式同步脏数据。大量脏数据可能需要相当长的时间才能写入磁盘，从而导致暂停。可以随时存在的脏数据总量可以用`sysctl`参数`vm.dirty_ratio`或`vm.dirty_bytes`来控制(更多细节请参考[第 14.1.5 节，“写回”](cha-tuning-memory.html#cha-tuning-memory-usage-writeback "14.1.5. Writeback"))。

Writeback :当前正在写入磁盘的内存量。

Mapped :系统调用`mmap`占用内存。

Shmem :进程组之间共享的内存，如 IPC 数据、`tmpfs`数据和共享匿名内存。

Slab :内核内部数据结构的内存分配。

SReclaimable :可以回收的板部分，例如缓存(inode、dentry 等。).

SUnreclaim :无法回收的楼板部分。

KernelStack :应用程序使用的内核空间内存量(通过系统调用)。

PageTables :专用于所有进程的页表的内存量。

NFS_Unstable :已经发送到服务器但尚未提交到服务器的 NFS 页面。

Bounce :用于块设备缓冲区的内存。

WritebackTmp : FUSE 用于临时写回缓冲区的内存。

CommitLimit :基于超量使用比率设置的系统可用内存量。仅当启用了严格超量承诺会计时，才会强制执行此操作。

Committed_AS :当前工作负载在最坏情况下需要的内存总量(RAM 和交换空间)的近似值。

VmallocTotal :分配的内核虚拟地址空间量。

VmallocUsed :已使用的内核虚拟地址空间量。

VmallocChunk :可用内核虚拟地址空间的最大连续块。

HardwareCorrupted :故障内存的数量(只有在使用 ECC RAM 时才能检测到)。

AnonHugePages :映射到用户空间页表的匿名大页。这些页面被透明地分配给进程，而不会被特别请求，因此它们也被称为*(THP)。

HugePages_Total :
由`SHM_HUGETLB`和`MAP_HUGETLB`使用或通过`hugetlbfs`文件系统使用的预分配的大页面数量，如`/proc/sys/vm/nr_hugepages`中所定义。

HugePages_Free :可用的大页面数量。

HugePages_Rsvd :提交的大页面数。

HugePages_Surp :超过的可用页面数 huge pages _ Total()，定义在`/proc/sys/vm/nr_overcommit_hugepages`中。

Hugepagesize :大页面的大小—在 AMD64/Intel 64 上，默认值为 2048 KB。

DirectMap4k etc. :映射到给定大小的页面的内核内存量(在本例中:4 kB)。

### 2.4.3 进程内存使用:`smaps`

使用像`top`或`ps`这样的标准工具是不可能准确确定某个进程消耗了多少内存的。如果需要精确的数据，可以使用内核 2.6.14 中引入的 smaps 子系统。它可以在`/proc/*PID*/smaps`中找到，并显示 ID 为 *PID 为* 的进程当时正在使用的干净和脏内存页面的数量。它区分了共享内存和私有内存，因此您可以看到该进程使用了多少内存，而不包括与其他进程共享的内存。更多信息见`/usr/src/linux/Documentation/filesystems/proc.txt`(需要安装软件包`kernel-source`)。

`smaps` 读起来很贵。因此，不建议定期对其进行监控，而是仅在密切监控某个流程时进行监控。

### 2.4.4 `numaTOP`

numaTOP 是用于 NUMA(非统一内存访问)系统的工具。该工具通过提供对 NUMA 系统的实时分析，帮助识别与 NUMA 相关的性能瓶颈。

一般来说，通过分析远程内存访问次数( RMA )、本地内存访问次数( LMA )以及 RMA/LMA 比率，numaTOP 允许您识别和调查具有较差局部性(即本地与远程内存使用的较差比率)的进程和线程。

PowerPC 和以下英特尔至强处理器支持 numaTOP:5500 系列、6500/7500 系列、5600 系列、E7-x8xx 系列和 E5-16xx/24xx/26xx/46xx 系列。

numaTOP 可以在官方软件库中获得，您可以使用`sudo zypper in numatop`命令安装该工具。要启动 numaTOP，运行`numatop`命令。要了解 numaTOP 的功能和用法，请使用`man numatop`命令。

## 2.5 联网

***![Tip](img/d61691e7a24e74558ece533d7932dfc0.png "Tip")

###### 提示:流量整形

如果网络带宽低于预期，您应该首先检查您的网段是否有任何活动的流量整形规则。 

### 2.5.1 基本网络诊断:`ip`

`ip`是设置和控制网络接口的强大工具。您还可以使用它来快速查看系统网络接口的基本统计信息。例如，接口是否打开，或者有多少错误、丢弃的数据包或数据包冲突。

如果运行`ip`时没有附加参数，它会显示一个帮助输出。要列出所有网络接口，请输入`ip addr show`(或缩写为`ip a`)。`ip addr show up`仅列出正在运行的网络接口。`ip -s link show`T5 设备只列出指定接口的统计数据:

```sh
***`#` ip -s link show br0
6: br0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DEFAULT
    link/ether 00:19:d1:72:d4:30 brd ff:ff:ff:ff:ff:ff
    RX: bytes  packets  errors  dropped overrun mcast
    6346104756 9265517  0       10860   0       0
    TX: bytes  packets  errors  dropped carrier collsns
    3996204683 3655523  0       0       0       0***
```

`ip`还可以显示接口(`link`)、路由表(`route`)等等——详情请参考`man 8 ip`。

```sh
***`#` ip route
default via 192.168.2.1 dev eth1
192.168.2.0/24 dev eth0  proto kernel  scope link  src 192.168.2.100
192.168.2.0/24 dev eth1  proto kernel  scope link  src 192.168.2.101
192.168.2.0/24 dev eth2  proto kernel  scope link  src 192.168.2.102***
```

```sh
***`#` ip link
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 52:54:00:44:30:51 brd ff:ff:ff:ff:ff:ff
3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 52:54:00:a3:c1:fb brd ff:ff:ff:ff:ff:ff
4: eth2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 52:54:00:32:a4:09 brd ff:ff:ff:ff:ff:ff***
```

### 2.5.2 显示进程的网络使用:`nethogs`

在某些情况下，例如，如果网络流量突然变得非常高，则需要快速找出是哪个(哪些)应用程序导致了流量。`nethogs`，一个设计类似于`top`的工具，显示所有相关流程的传入和传出流量:

```sh
***PID   USER  PROGRAM                                DEV   SENT   RECEIVED
27145 root   zypper                                eth0  5.719  391.749 KB/sec
?     root   ..0:113:80c0:8080:10:160:0:100:30015        0.102    2.326 KB/sec
26635 tux    /usr/lib64/firefox/firefox            eth0  0.026    0.026 KB/sec
?     root   ..0:113:80c0:8080:10:160:0:100:30045        0.000    0.021 KB/sec
?     root   ..0:113:80c0:8080:10:160:0:100:30045        0.000    0.018 KB/sec
?     root   ..0:113:80c0:8080:10:160:0:100:30015        0.000    0.018 KB/sec
?     root   ..0:113:80c0:8080:10:160:0:100:30045        0.000    0.017 KB/sec
?     root   ..0:113:80c0:8080:10:160:0:100:30045        0.000    0.017 KB/sec
?     root   ..0:113:80c0:8080:10:160:0:100:30045        0.069    0.000 KB/sec
?     root   unknown TCP                                 0.000    0.000 KB/sec

TOTAL                                                  5.916  394.192 KB/sec***
```

像在`top`中一样，`nethogs`具有交互命令的特性:

| M :显示模式之间的循环(kb/s，kb，b，mb) |
| R :按收到的排序 |
| S :按发送的排序 |
| 问:退出 |

### 2.5.3 以太网卡详细:ethtool

`ethtool`可以显示和更改您的以太网网络设备的详细信息。默认情况下，它打印指定设备的当前设置。

```sh
***`#` ethtool eth0
Settings for eth0:
 Supported ports: [ TP ]
 Supported link modes:   10baseT/Half 10baseT/Full
                         100baseT/Half 100baseT/Full
                         1000baseT/Full
 Supports auto-negotiation: Yes
 Advertised link modes:  10baseT/Half 10baseT/Full
                         100baseT/Half 100baseT/Full
                         1000baseT/Full
 Advertised pause frame use: No
[...]
 Link detected: yes***
```

*下表显示了可用于查询仪器特定信息的`ethtool`选项:

###### *表 2.1:`ethtool`的查询选项列表

<colgroup><col class="1"><col class="2"></colgroup>

| `ethtool`选项 | 它会向设备查询 |
| --------------| ------------- |
| [构成动植物的古名或拉丁化的现代名］ | 暂停参数信息 |
| -丙 | 中断合并信息 |
| -g | Rx/Tx(接收/发送)振铃参数信息 |
| ［构成来自拉丁语、结尾为-us 的名词的复数］ | 相关驱动程序信息 |
| -k | 卸载信息 |
| 构成名词复数 | 特定于网卡和驱动程序的统计数据 |

### 2.5.4 显示网络状态:`ss`

`ss`是一个转储套接字统计数据的工具，取代了`netstat`命令。要列出所有连接，请使用不带参数的`ss`:

```sh
***`#` ss
Netid  State      Recv-Q Send-Q   Local Address:Port       Peer Address:Port
u_str  ESTAB      0      0                    * 14082                 * 14083
u_str  ESTAB      0      0                    * 18582                 * 18583
u_str  ESTAB      0      0                    * 19449                 * 19450
u_str  ESTAB      0      0      @/tmp/dbus-gmUUwXABPV 18784           * 18783
u_str  ESTAB      0      0      /var/run/dbus/system_bus_socket 19383 * 19382
u_str  ESTAB      0      0      @/tmp/dbus-gmUUwXABPV 18617           * 18616
u_str  ESTAB      0      0      @/tmp/dbus-58TPPDv8qv 19352           * 19351
u_str  ESTAB      0      0                    * 17658                 * 17657
u_str  ESTAB      0      0                    * 17693                 * 17694
[..]***
```

要显示当前打开的所有网络端口，请使用以下命令:

```sh
***`#` ss -l
Netid  State      Recv-Q Send-Q      Local Address:Port  Peer Address:Port
nl     UNCONN     0      0                 rtnl:4195117                  *
nl     UNCONN     0      0       rtnl:wickedd-auto4/811                  *
nl     UNCONN     0      0       rtnl:wickedd-dhcp4/813                  *
nl     UNCONN     0      0                 rtnl:4195121                  *
nl     UNCONN     0      0                 rtnl:4195115                  *
nl     UNCONN     0      0       rtnl:wickedd-dhcp6/814                  *
nl     UNCONN     0      0                  rtnl:kernel                  *
nl     UNCONN     0      0             rtnl:wickedd/817                  *
nl     UNCONN     0      0                 rtnl:4195118                  *
nl     UNCONN     0      0                rtnl:nscd/706                  *
nl     UNCONN     4352   0              tcpdiag:ss/2381                  *
[...]***
```

显示网络连接时，您可以指定要显示的套接字类型:例如 TCP ( `-t`)或 UDP ( `-u`)。`-p`选项显示每个套接字所属程序的 PID 和名称。

以下示例列出了所有 TCP 连接以及使用这些连接的程序。`-a`选项确保显示所有已建立的连接(监听和非监听)。`-p`选项显示每个套接字所属程序的 PID 和名称。

```sh
***`#` ss -t -a -p
State    Recv-Q Send-Q  Local Address:Port   Peer Address:Port
LISTEN   0      128                  *:ssh                 *:*  users:(("sshd",1551,3))
LISTEN   0      100         127.0.0.1:smtp                 *:*  users:(("master",1704,13))
ESTAB    0      132      10.120.65.198:ssh  10.120.4.150:55715  users:(("sshd",2103,5))
LISTEN   0      128                 :::ssh                :::*  users:(("sshd",1551,4))
LISTEN   0      100               ::1:smtp                :::*  users:(("master",1704,14))***
```

## 2.6 `/proc`文件系统

`/proc`文件系统是一个伪文件系统，内核以虚拟文件的形式保存重要信息。例如，使用以下命令显示 CPU 类型:

```sh
***`>` cat /proc/cpuinfo
processor       : 0
vendor_id       : GenuineIntel
cpu family      : 6
model           : 30
model name      : Intel(R) Core(TM) i5 CPU         750  @ 2.67GHz
stepping        : 5
microcode       : 0x6
cpu MHz         : 1197.000
cache size      : 8192 KB
physical id     : 0
siblings        : 4
core id         : 0
cpu cores       : 4
apicid          : 0
initial apicid  : 0
fpu             : yes
fpu_exception   : yes
cpuid level     : 11
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni dtes64 monitor ds_cpl vmx smx est tm2 ssse3 cx16 xtpr pdcm sse4_1 sse4_2 popcnt lahf_lm ida dtherm tpr_shadow vnmi flexpriority ept vpid
bogomips        : 5333.85
clflush size    : 64
cache_alignment : 64
address sizes   : 36 bits physical, 48 bits virtual
power management:
[...]***
```

***![Tip](img/d61691e7a24e74558ece533d7932dfc0.png "Tip")

###### 提示:详细的处理器信息

运行`x86info`还可以获得关于 AMD64/Intel 64 架构处理器的详细信息。

使用以下命令查询中断的分配和使用:

```sh
***`>` cat /proc/interrupts
           CPU0       CPU1       CPU2       CPU3
  0:        121          0          0          0   IO-APIC-edge      timer
  8:          0          0          0          1   IO-APIC-edge      rtc0
  9:          0          0          0          0   IO-APIC-fasteoi   acpi
 16:          0      11933          0          0   IO-APIC-fasteoi   ehci_hcd:+
 18:          0          0          0          0   IO-APIC-fasteoi   i801_smbus
 19:          0     117978          0          0   IO-APIC-fasteoi   ata_piix,+
 22:          0          0    3275185          0   IO-APIC-fasteoi   enp5s1
 23:     417927          0          0          0   IO-APIC-fasteoi   ehci_hcd:+
 40:    2727916          0          0          0  HPET_MSI-edge      hpet2
 41:          0    2749134          0          0  HPET_MSI-edge      hpet3
 42:          0          0    2759148          0  HPET_MSI-edge      hpet4
 43:          0          0          0    2678206  HPET_MSI-edge      hpet5
 45:          0          0          0          0   PCI-MSI-edge      aerdrv, P+
 46:          0          0          0          0   PCI-MSI-edge      PCIe PME,+
 47:          0          0          0          0   PCI-MSI-edge      PCIe PME,+
 48:          0          0          0          0   PCI-MSI-edge      PCIe PME,+
 49:          0          0          0        387   PCI-MSI-edge      snd_hda_i+
 50:     933117          0          0          0   PCI-MSI-edge      nvidia
NMI:       2102       2023       2031       1920   Non-maskable interrupts
LOC:         92         71         57         41   Local timer interrupts
SPU:          0          0          0          0   Spurious interrupts
PMI:       2102       2023       2031       1920   Performance monitoring int+
IWI:      47331      45725      52464      46775   IRQ work interrupts
RTR:          2          0          0          0   APIC ICR read retries
RES:     472911     396463     339792     323820   Rescheduling interrupts
CAL:      48389      47345      54113      50478   Function call interrupts
TLB:      28410      26804      24389      26157   TLB shootdowns
TRM:          0          0          0          0   Thermal event interrupts
THR:          0          0          0          0   Threshold APIC interrupts
MCE:          0          0          0          0   Machine check exceptions
MCP:         40         40         40         40   Machine check polls
ERR:          0
MIS:          0***
```

可执行文件和库的地址分配包含在`maps`文件中:

```sh
***`>` cat /proc/self/maps
08048000-0804c000 r-xp 00000000 03:03 17753      /bin/cat
0804c000-0804d000 rw-p 00004000 03:03 17753      /bin/cat
0804d000-0806e000 rw-p 0804d000 00:00 0          [heap]
b7d27000-b7d5a000 r--p 00000000 03:03 11867      /usr/lib/locale/en_GB.utf8/
b7d5a000-b7e32000 r--p 00000000 03:03 11868      /usr/lib/locale/en_GB.utf8/
b7e32000-b7e33000 rw-p b7e32000 00:00 0
b7e33000-b7f45000 r-xp 00000000 03:03 8837       /lib/libc-2.3.6.so
b7f45000-b7f46000 r--p 00112000 03:03 8837       /lib/libc-2.3.6.so
b7f46000-b7f48000 rw-p 00113000 03:03 8837       /lib/libc-2.3.6.so
b7f48000-b7f4c000 rw-p b7f48000 00:00 0
b7f52000-b7f53000 r--p 00000000 03:03 11842      /usr/lib/locale/en_GB.utf8/
[...]
b7f5b000-b7f61000 r--s 00000000 03:03 9109       /usr/lib/gconv/gconv-module
b7f61000-b7f62000 r--p 00000000 03:03 9720       /usr/lib/locale/en_GB.utf8/
b7f62000-b7f76000 r-xp 00000000 03:03 8828       /lib/ld-2.3.6.so
b7f76000-b7f78000 rw-p 00013000 03:03 8828       /lib/ld-2.3.6.so
bfd61000-bfd76000 rw-p bfd61000 00:00 0          [stack]
ffffe000-fffff000 ---p 00000000 00:00 0          [vdso]***
```

可以从/proc 文件系统中获得更多的信息。一些重要的文件及其内容如下:*

`/proc/devices`:可用设备

`/proc/modules`:内核模块已加载

`/proc/cmdline`:内核命令行

`/proc/meminfo`:关于内存使用的详细信息

`/proc/config.gz`:`gzip`-当前运行的内核的压缩配置文件

/proc/*PID/:在`/proc/`*目录中查找当前运行的进程信息，其中 *【NNN】* 是相关进程的进程 ID (PID)。每个流程都能在`/proc/self/`中找到自己的特色。

更多信息可在文本文件`/usr/src/linux/Documentation/filesystems/proc.txt`中获得(该文件在安装软件包`kernel-source`时可用)。

### 2.6.1 `procinfo` 

命令`procinfo`总结了来自`/proc`文件系统的重要信息:

```sh
****`>` procinfo
Linux 3.11.10-17-desktop (geeko@buildhost) (gcc 4.8.1 20130909) #1 4CPU [jupiter.example.com]

Memory:      Total        Used        Free      Shared     Buffers      Cached
Mem:       8181908     8000632      181276           0       85472     2850872
Swap:     10481660        1576    10480084

Bootup: Mon Jul 28 09:54:13 2014    Load average: 1.61 0.85 0.74 2/904 25949

user  :       1:54:41.84  12.7%  page in :    2107312  disk 1:    52212r   20199w
nice  :       0:00:00.46   0.0%  page out:    1714461  disk 2:    19387r   10928w
system:       0:25:38.00   2.8%  page act:     466673  disk 3:      548r      10w
IOwait:       0:04:16.45   0.4%  page dea:     272297
hw irq:       0:00:00.42   0.0%  page flt:  105754526
sw irq:       0:01:26.48   0.1%  swap in :          0
idle  :      12:14:43.65  81.5%  swap out:        394
guest :       0:02:18.59   0.2%
uptime:       3:45:22.24         context :   99809844

irq  0:       121 timer                 irq 41:   3238224 hpet3
irq  8:         1 rtc0                  irq 42:   3251898 hpet4
irq  9:         0 acpi                  irq 43:   3156368 hpet5
irq 16:     14589 ehci_hcd:usb1         irq 45:         0 aerdrv, PCIe PME
irq 18:         0 i801_smbus            irq 46:         0 PCIe PME, pciehp
irq 19:    124861 ata_piix, ata_piix, f irq 47:         0 PCIe PME, pciehp
irq 22:   3742817 enp5s1                irq 48:         0 PCIe PME, pciehp
irq 23:    479248 ehci_hcd:usb2         irq 49:       387 snd_hda_intel
irq 40:   3216894 hpet2                 irq 50:   1088673 nvidia****
```

要查看所有信息，请使用参数`-a`。参数`-nN`每隔 *N* 秒产生一次信息更新。在这种情况下，按下 Q 终止程序。

默认情况下，会显示累积值。参数`-d`产生差值。`procinfo -dn5`显示最近五秒内发生变化的数值:

### 2.6.2 系统控制参数:`/proc/sys/`

系统控制参数用于在运行时修改 Linux 内核参数。它们位于`/proc/sys/`中，可以用`sysctl`命令查看和修改。要列出所有参数，运行`sysctl` `-a`。单个参数可以用`sysctl` *参数名* 列出。

参数被分成不同的类别，可以用`sysctl` *类别* 列出，或者通过列出各自目录的内容。下面列出了最重要的类别。进一步阅读的链接需要安装包`kernel-source`。

`sysctl dev` (`/proc/sys/dev/`)

设备特定的信息。

`sysctl fs` (`/proc/sys/fs/`)

使用的文件句柄、配额和其他面向文件系统的参数。详情见`/usr/src/linux/Documentation/sysctl/fs.txt`。

`sysctl kernel` (`/proc/sys/kernel/`)

关于任务调度程序、系统共享内存和其他内核相关参数的信息。详情见`/usr/src/linux/Documentation/sysctl/kernel.txt`

`sysctl net` (`/proc/sys/net/`)

关于网桥和一般网络参数的信息(主要是`ipv4/`子目录)。详情见`/usr/src/linux/Documentation/sysctl/net.txt`

`sysctl vm` (`/proc/sys/vm/`)

此路径中的条目与虚拟内存、交换和缓存的信息相关。详情见`/usr/src/linux/Documentation/sysctl/vm.txt`

要设置或更改当前会话的参数，使用命令`sysctl` `-w` *参数* = *值*。要永久更改设置，添加一行*参数* = *值*到`/etc/sysctl.conf`。

## 2.7 硬件信息

### 2.7.1 PCI 资源:`lspci`

****![Note](img/ff87f0b59d655d477bfebbc447e7a566.png "Note")

###### 注:访问 PCI 配置。

大多数操作系统需要 root 用户权限来授予对计算机 PCI 配置的访问权限。

****命令`lspci`列出了 PCI 资源:****

```sh
****`#` lspci
00:00.0 Host bridge: Intel Corporation 82845G/GL[Brookdale-G]/GE/PE \
    DRAM Controller/Host-Hub Interface (rev 01)
00:01.0 PCI bridge: Intel Corporation 82845G/GL[Brookdale-G]/GE/PE \
    Host-to-AGP Bridge (rev 01)
00:1d.0 USB Controller: Intel Corporation 82801DB/DBL/DBM \
    (ICH4/ICH4-L/ICH4-M) USB UHCI Controller #1 (rev 01)
00:1d.1 USB Controller: Intel Corporation 82801DB/DBL/DBM \
    (ICH4/ICH4-L/ICH4-M) USB UHCI Controller #2 (rev 01)
00:1d.2 USB Controller: Intel Corporation 82801DB/DBL/DBM \
    (ICH4/ICH4-L/ICH4-M) USB UHCI Controller #3 (rev 01)
00:1d.7 USB Controller: Intel Corporation 82801DB/DBM \
    (ICH4/ICH4-M) USB2 EHCI Controller (rev 01)
00:1e.0 PCI bridge: Intel Corporation 82801 PCI Bridge (rev 81)
00:1f.0 ISA bridge: Intel Corporation 82801DB/DBL (ICH4/ICH4-L) \
    LPC Interface Bridge (rev 01)
00:1f.1 IDE interface: Intel Corporation 82801DB (ICH4) IDE \
    Controller (rev 01)
00:1f.3 SMBus: Intel Corporation 82801DB/DBL/DBM (ICH4/ICH4-L/ICH4-M) \
    SMBus Controller (rev 01)
00:1f.5 Multimedia audio controller: Intel Corporation 82801DB/DBL/DBM \
    (ICH4/ICH4-L/ICH4-M) AC'97 Audio Controller (rev 01)
01:00.0 VGA compatible controller: Matrox Graphics, Inc. G400/G450 (rev 85)
02:08.0 Ethernet controller: Intel Corporation 82801DB PRO/100 VE (LOM) \
    Ethernet Controller (rev 81)****
```

****使用`-v`会产生更详细的列表:****

```sh
****`#` lspci -v
[...]
00:03.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet \
Controller (rev 02)
  Subsystem: Intel Corporation PRO/1000 MT Desktop Adapter
  Flags: bus master, 66MHz, medium devsel, latency 64, IRQ 19
  Memory at f0000000 (32-bit, non-prefetchable) [size=128K]
  I/O ports at d010 [size=8]
  Capabilities: [dc] Power Management version 2
  Capabilities: [e4] PCI-X non-bridge device
  Kernel driver in use: e1000
  Kernel modules: e1000****
```

关于设备名称解析的信息从文件`/usr/share/pci.ids`中获得。该文件中未列出的 PCI IDs 被标记为未知设备。

参数`-vv`产生程序可以查询的所有信息。要查看纯数值，请使用参数`-n`。

### 2.7.2 USB 设备:`lsusb`

命令`lsusb`列出了所有的 USB 设备。使用选项`-v`，打印更详细的列表。详细信息从`/proc/bus/usb/`目录中读取。以下是`lsusb`连接这些 USB 设备的输出:hub、内存条、硬盘、鼠标。

```sh
****`#` lsusb
Bus 004 Device 007: ID 0ea0:2168 Ours Technology, Inc. Transcend JetFlash \
    2.0 / Astone USB Drive
Bus 004 Device 006: ID 04b4:6830 Cypress Semiconductor Corp. USB-2.0 IDE \
    Adapter
Bus 004 Device 005: ID 05e3:0605 Genesys Logic, Inc.
Bus 004 Device 001: ID 0000:0000
Bus 003 Device 001: ID 0000:0000
Bus 002 Device 001: ID 0000:0000
Bus 001 Device 005: ID 046d:c012 Logitech, Inc. Optical Mouse
Bus 001 Device 001: ID 0000:0000****
```

### 2.7.3 可视化子系统工具`tmon`

`tmon`是一款帮助可视化、调整和测试复杂热子系统的工具。无参数启动时，`tmon`在监控模式下运行:

```sh
****┌──────THERMAL ZONES(SENSORS)──────────────────────────────┐
│Thermal Zones:                 acpitz00                   │
│Trip Points:                   PC                         │
└──────────────────────────────────────────────────────────┘
┌─────────── COOLING DEVICES ──────────────────────────────┐
│ID  Cooling Dev   Cur    Max   Thermal Zone Binding       │
│00    Processor     0      3   ││││││││││││               │
│01    Processor     0      3   ││││││││││││               │
│02    Processor     0      3   ││││││││││││               │
│03    Processor     0      3   ││││││││││││               │
│04 intel_powerc    -1     50   ││││││││││││               │
└──────────────────────────────────────────────────────────┘
┌──────────────────────────────────────────────────────────┐
│                         10        20        30        40 │
│acpitz 0:[  8][>>>>>>>>>P9                    C31         │
└──────────────────────────────────────────────────────────┘
┌────────────────── CONTROLS ──────────────────────────────┐
│PID gain: kp=0.36 ki=5.00 kd=0.19 Output 0.00             │
│Target Temp: 65.0C, Zone: 0, Control Device: None         │
└──────────────────────────────────────────────────────────┘

Ctrl-c - Quit   TAB - Tuning****
```

有关如何解释数据、如何记录热数据以及如何使用`tmon`测试和调整冷却设备和传感器的详细信息，请参考手册页:`man 8 tmon`。默认情况下不安装 tmon 包。

### 2.7.4 MCELog:机器检查异常(MCE)

`mcelog`包记录并解析/翻译硬件错误的机器检查异常(MCE ),包括 I/O、CPU 和内存错误。此外，mcelog 还能在发生缓存错误时处理预测性坏页离线和自动内核离线。以前，这由每小时执行一次的 cron 作业来管理。现在，mcelog 守护程序会立即处理硬件错误。

****![Note](img/ff87f0b59d655d477bfebbc447e7a566.png "Note")

###### 注意:支持 AMD 可扩展 MCA

openSUSE Leap 支持 AMD 的可扩展机器校验架构(Scalable MCA)。可扩展 MCA 改进了 AMD Zen 处理器中的硬件错误报告。它扩展了 MCA 库中记录的信息，以改进错误处理和更好的可诊断性。

`mcelog`捕获 MCA 消息(`rasdaemon`和`dmesg`也捕获 MCA 消息)。有关详细信息，请参见 AMD 家族 17h 型号 01h，B1 修订版处理器的 *处理器编程参考(PPR)的第 3.1 节* 机器检查架构，[http://developer . AMD . com/WordPress/media/2017/11/54945 _ PPR _ 家族 _17h_Models_00h-0Fh.pdf](http://developer.amd.com/wordpress/media/2017/11/54945_PPR_Family_17h_Models_00h-0Fh.pdf) 。

mcelog 在`/etc/mcelog/mcelog.conf`中配置。配置选项记录在`man mcelog`和 http://mcelog.org/ 中。以下示例仅显示对默认文件的更改:(http://mcelog.org/)

```sh
****daemon = yes
filter = yes
filter-memory-errors = yes
no-syslog = yes
logfile = /var/log/mcelog
run-credentials-user = root
run-credentials-group = nobody
client-group = root
socket-path = /var/run/mcelog-client****
```

默认情况下，不会启用 mcelog 服务。可以通过 YaST 系统服务编辑器或命令行来启用和启动该服务:

```sh
****`#` systemctl enable mcelog
`#` systemctl start mcelog****
```

### 2.7.5 amd64/Intel 64:dmode:DMI 表解码器

`dmidecode`显示机器的 DMI 表，其中包含硬件的序列号和 BIOS 版本等信息。

```sh
****`#` dmidecode
# dmidecode 2.12
SMBIOS 2.5 present.
27 structures occupying 1298 bytes.
Table at 0x000EB250.

Handle 0x0000, DMI type 4, 35 bytes
Processor Information
        Socket Designation: J1PR
        Type: Central Processor
        Family: Other
        Manufacturer: Intel(R) Corporation
        ID: E5 06 01 00 FF FB EB BF
        Version: Intel(R) Core(TM) i5 CPU         750  @ 2.67GHz
        Voltage: 1.1 V
        External Clock: 133 MHz
        Max Speed: 4000 MHz
        Current Speed: 2667 MHz
        Status: Populated, Enabled
        Upgrade: Other
        L1 Cache Handle: 0x0004
        L2 Cache Handle: 0x0003
        L3 Cache Handle: 0x0001
        Serial Number: Not Specified
        Asset Tag: Not Specified
        Part Number: Not Specified
[..]****
```

## 2.8 文件和文件系统

### 2.8.1 确定文件类型:`file`

命令`file`通过检查`/usr/share/misc/magic`来确定文件或文件列表的类型。

```sh
****`>` file /usr/bin/file
/usr/bin/file: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), \
    for GNU/Linux 2.6.4, dynamically linked (uses shared libs), stripped****
```

参数`-f *LIST*`指定了一个带有要检查的文件名列表的文件。`-z`允许`file`查看压缩文件:

```sh
****`>` file /usr/share/man/man1/file.1.gz
/usr/share/man/man1/file.1.gz: gzip compressed data, from Unix, max compression
`>` file -z /usr/share/man/man1/file.1.gz
/usr/share/man/man1/file.1.gz: troff or preprocessor input text \
    (gzip compressed data, from Unix, max compression)****
```

*参数`-i`输出 mime 类型的字符串，而不是传统的描述。

```sh
****`>` file -i /usr/share/misc/magic
/usr/share/misc/magic: text/plain charset=utf-8****
```

### 2.8.2 文件系统及其用法:`mount`、`df`和`du`

命令`mount`显示哪个文件系统(设备和类型)被挂载在哪个挂载点:

```sh
****`#` mount
/dev/sda2 on / type ext4 (rw,acl,user_xattr)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
debugfs on /sys/kernel/debug type debugfs (rw)
devtmpfs on /dev type devtmpfs (rw,mode=0755)
tmpfs on /dev/shm type tmpfs (rw,mode=1777)
devpts on /dev/pts type devpts (rw,mode=0620,gid=5)
/dev/sda3 on /home type ext3 (rw)
securityfs on /sys/kernel/security type securityfs (rw)
fusectl on /sys/fs/fuse/connections type fusectl (rw)
gvfs-fuse-daemon on /home/tux/.gvfs type fuse.gvfs-fuse-daemon \
(rw,nosuid,nodev,user=tux)****
```

使用命令`df`获取有关文件系统总使用量的信息。参数`-h`(或`--human-readable`)将输出转换成普通用户可以理解的形式。

```sh
****`>` df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/sda2              20G  5,9G   13G  32% /
devtmpfs              1,6G  236K  1,6G   1% /dev
tmpfs                 1,6G  668K  1,6G   1% /dev/shm
/dev/sda3             208G   40G  159G  20% /home****
```

用命令`du`显示给定目录及其子目录中所有文件的总大小。参数`-s`抑制详细信息的输出，只给出每个参数的总数。`-h`再次将输出转换成人类可读的形式:

```sh
****`>` du -sh /opt
192M    /opt****
```

### 2.8.3 关于 ELF 二进制文件的附加信息

使用`readelf`实用程序读取二进制文件的内容。这甚至适用于为其他硬件架构构建的 ELF 文件:

```sh
****`>` readelf --file-header /bin/ls
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x402540
  Start of program headers:          64 (bytes into file)
  Start of section headers:          95720 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         9
  Size of section headers:           64 (bytes)
  Number of section headers:         32
  Section header string table index: 31****
```

### 2.8.4 文件属性:`stat`

命令`stat`显示文件属性:

```sh
****`>` stat /etc/profile
  File: `/etc/profile'
  Size: 9662            Blocks: 24         IO Block: 4096   regular file
Device: 802h/2050d      Inode: 132349      Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2009-03-20 07:51:17.000000000 +0100
Modify: 2009-01-08 19:21:14.000000000 +0100
Change: 2009-03-18 12:55:31.000000000 +0100****
```

参数`--file-system`产生指定文件所在的文件系统的详细属性:

```sh
****`>` stat /etc/profile --file-system
  File: "/etc/profile"
    ID: d4fb76e70b4d1746 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 2581445    Free: 1717327    Available: 1586197
Inodes: Total: 655776     Free: 490312****
```

## 2.9 用户信息

### 2.9.1 用户访问文件:`fuser`

确定哪些进程或用户当前正在访问某些文件会很有用。例如，假设您想要卸载在`/mnt`装载的文件系统。`umount`返回“设备忙”然后，命令`fuser`可以用于确定哪些进程正在访问设备:

```sh
****`>` fuser -v /mnt/*

                     USER        PID ACCESS COMMAND
/mnt/notes.txt       tux    26597 f....  less****
```

在另一个终端上运行的`less`进程终止后，可以成功卸载文件系统。当与`-k`选项一起使用时，`fuser`也会终止访问文件的进程。

### 2.9.2 谁在做什么:`w`

使用命令`w`，找出谁登录了系统，每个用户在做什么。例如:

```sh
****`>` w
 16:00:59 up 1 day,  2:41,  3 users,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
tux      :0       console          Wed13   ?xdm?   8:15   0.03s /usr/lib/gdm/gd
tux      console  :0               Wed13   26:41m  0.00s  0.03s /usr/lib/gdm/gd
tux      pts/0    :0               Wed13   20:11   0.10s  2.89s /usr/lib/gnome-****
```

如果其他系统的任何用户已经远程登录，参数`-f`显示他们已经建立连接的计算机。

## 2.10 时间和日期

### 2.10.1 时间测量同`time`

使用`time`实用程序确定命令花费的时间。这个实用程序有两个版本:作为 Bash 内置和作为程序(`/usr/bin/time`)。

```sh
****`>` time find . > /dev/null

real    0m4.051s1
user    0m0.042s2
sys     0m0.205s3****
```

| [1](#co-util-time-real) | 从命令启动到完成所经过的实际时间。 |
| [2](#co-util-time-user) | 由`times`系统调用报告的用户 CPU 时间。 |
| [3](#co-util-time-sys) | 系统调用`times`报告的系统 CPU 时间。 |

`/usr/bin/time`的输出要详细得多。建议使用`-v`开关运行它，以产生人类可读的输出。

```sh
****/usr/bin/time -v find . > /dev/null
        Command being timed: "find ."
        User time (seconds): 0.24
        System time (seconds): 2.08
        Percent of CPU this job got: 25%
        Elapsed (wall clock) time (h:mm:ss or m:ss): 0:09.03
        Average shared text size (kbytes): 0
        Average unshared data size (kbytes): 0
        Average stack size (kbytes): 0
        Average total size (kbytes): 0
        Maximum resident set size (kbytes): 2516
        Average resident set size (kbytes): 0
        Major (requiring I/O) page faults: 0
        Minor (reclaiming a frame) page faults: 1564
        Voluntary context switches: 36660
        Involuntary context switches: 496
        Swaps: 0
        File system inputs: 0
        File system outputs: 0
        Socket messages sent: 0
        Socket messages received: 0
        Signals delivered: 0
        Page size (bytes): 4096
        Exit status: 0****
```

## 2.11 绘制您的数据: RRDtool

你身边的世界有很多数据，可以很容易的用时间来衡量。例如，温度的变化，或者计算机网络接口发送或接收的数据量。RRDtool 可以帮助您以详细的、可定制的图形来存储和可视化这些数据。

RRDtool 可用于大多数 Unix 平台和 Linux 发行版。 openSUSE Leap 舰 RRDtool 也一样。用 YaST 安装它，或者输入

`zypper` `install` *rrdtool* 在命令行中为`root`。

****![Tip](img/d61691e7a24e74558ece533d7932dfc0.png "Tip")

###### 提示:绑定

RRDtool 提供了 Perl、Python、Ruby 和 PHP 绑定，因此您可以用自己喜欢的脚本语言编写自己的监控脚本。**** 

### 2.11.1 RRD tool 如何工作

RRDtool 是 *轮循数据库工具* 的缩写。 *循环调度* 是一种处理恒定数据量的方法。它使用循环缓冲区的原理，在循环缓冲区中，正在读取的数据行既没有结尾也没有开头。RRDtool 使用循环数据库来存储和读取其数据。

如上所述，RRDtool 设计用于处理随时间变化的数据。理想的情况是传感器反复读取测量数据(如温度、速度等)。)，然后以给定的格式导出它们。这样的数据对于 RRDtool 来说是完美的，很容易处理它们并创建所需的输出。

有时不可能自动和定期地获得数据。在提供给 RRDtool 之前，需要对它们的格式进行预处理，甚至经常需要手动操作 RRDtool。

下面是 RRDtool 基本用法的一个简单示例。它说明了通常 RRDtool 工作流的所有三个重要阶段: *创建* 数据库， *更新* 测量值，以及 *查看* 输出。

### 2.11.2 一个实际例子

假设我们想要收集并查看 Linux 系统中随时间变化的内存使用信息。为了让这个例子更生动，我们以 4 秒为间隔测量 40 秒内的当前空闲内存。启动和关闭三个通常消耗大量系统内存的应用程序:Firefox Web 浏览器、Evolution 电子邮件客户端和 Eclipse 开发框架。

#### 2.11.2.1 收集数据

RRDtool 经常用于测量和可视化网络流量。在这种情况下，使用简单网络管理协议(SNMP)。该协议可以向网络设备查询其内部计数器的相关值。这些值将与 RRDtool 一起存储。有关 SNMP 的更多信息，请参见[http://www.net-snmp.org/](http://www.net-snmp.org/)。

我们的情况不同，我们需要手动获取数据。一个助手脚本`free_mem.sh`重复读取空闲内存的当前状态，并将其写入标准输出。

```sh
***`>` cat free_mem.sh
INTERVAL=4
for steps in {1..10}
do
    DATE=`date +%s`
    FREEMEM=`free -b | grep "Mem" | awk '{ print $4 }'`
    sleep $INTERVAL
    echo "rrdtool update free_mem.rrd $DATE:$FREEMEM"
done***
```

*   时间间隔设置为 4 秒，通过`sleep`命令实现。

*   RRDtool 接受特殊格式的时间信息——所谓的 *Unix 时间* 。它被定义为自 1970 年 1 月 1 日午夜(UTC)以来的秒数。比如 1272907114 代表 2010-05-03 17:18:34。

*   用`free` `-b`以字节为单位报告空闲内存信息。倾向于提供基本单位(字节)而不是多个单位(如千字节)。

*   带有`echo ...`命令的行包含数据库文件的未来名称(`free_mem.rrd`)，它们一起创建了一个用于更新 RRDtool 值的命令行。

运行`free_mem.sh`之后，您会看到类似如下的输出:

```sh
***`>` sh free_mem.sh
rrdtool update free_mem.rrd 1272974835:1182994432
rrdtool update free_mem.rrd 1272974839:1162817536
rrdtool update free_mem.rrd 1272974843:1096269824
rrdtool update free_mem.rrd 1272974847:1034219520
rrdtool update free_mem.rrd 1272974851:909438976
rrdtool update free_mem.rrd 1272974855:832454656
rrdtool update free_mem.rrd 1272974859:829120512
rrdtool update free_mem.rrd 1272974863:1180377088
rrdtool update free_mem.rrd 1272974867:1179369472
rrdtool update free_mem.rrd 1272974871:1181806592***
```

将命令的输出重定向到一个文件是很方便的

`sh free_mem.sh > free_mem_updates.log`

以简化其未来的执行。

#### 2.11.2.2 创建数据库

使用以下命令为我们的示例创建初始循环数据库:

```sh
***`>` rrdtool create free_mem.rrd --start 1272974834 --step=4 \
DS:memory:GAUGE:600:U:U RRA:AVERAGE:0.5:1:24***
```

###### 点注意事项

*   该命令创建一个名为`free_mem.rrd`的文件，用于将我们的测量值存储在循环类型的数据库中。

*   `--start`选项指定第一个值被添加到数据库的时间( Unix 时间)。在本例中，它比`free_mem.sh`输出的第一个时间值(1272974835)小 1。

*   `--step`以秒为单位指定将测量数据提供给数据库的时间间隔。

*   `DS:memory:GAUGE:600:U:U`部分为数据库引入了新的数据源。它叫做 *内存* ，类型为 *仪表* ，两次更新之间的最大次数为 600 秒，测量范围内的 *最小* 和*最大值* （U)。

*   `RRA:AVERAGE:0.5:1:24`创建循环赛档案(RRA)，其存储的数据通过 *合并函数* (CF)进行处理，合并函数计算数据点，合并函数的参数被附加到行尾。

如果没有显示错误信息，则在当前目录下创建`free_mem.rrd`数据库:

```sh
****`>` ls -l free_mem.rrd
-rw-r--r-- 1 tux users 776 May  5 12:50 free_mem.rrd****
```

#### 2.11.2.3 更新数据库值

创建数据库后，您需要用测量的数据填充它。在 2.11.2.1 的部分，“采集数据”(cha-util.html#sec-util-rrdtool-example-collect "2.11.2.1. Collecting data")，我们已经准备好了由`rrdtool update`命令组成的文件`free_mem_updates.log`。这些命令为我们更新数据库值。

```sh
****`>` sh free_mem_updates.log; ls -l free_mem.rrd
-rw-r--r--  1 tux users  776 May  5 13:29 free_mem.rrd****
```

如您所见，`free_mem.rrd`的大小保持不变，甚至在更新其数据之后。

#### 2.11.2.4 查看测量值

我们已经测量了这些值，创建了数据库，并将测量值存储在其中。现在我们可以使用数据库，并检索或查看它的值。

要从我们的数据库中检索所有值，请在命令行中输入以下内容:

```sh
****`>` rrdtool fetch free_mem.rrd AVERAGE --start 1272974830 \
--end 1272974871
          memory
1272974832: nan
1272974836: 1.1729059840e+09
1272974840: 1.1461806080e+09
1272974844: 1.0807572480e+09
1272974848: 1.0030243840e+09
1272974852: 8.9019289600e+08
1272974856: 8.3162112000e+08
1272974860: 9.1693465600e+08
1272974864: 1.1801251840e+09
1272974868: 1.1799787520e+09
1272974872: nan****
```

###### 点注意事项

*   `AVERAGE`将从数据库中获取平均值点，因为仅定义了一个数据源(【2.11.2.2】、【创建数据库】、`AVERAGE`处理的)且没有其他功能可用。

*   输出的第一行打印出在 2.11.2.2 的[部分“创建数据库”](cha-util.html#sec-util-rrdtool-example-create "2.11.2.2. Creating the database")中定义的数据源名称。

*   左边的结果栏代表各个时间点，而右边的结果栏代表以科学记数法表示的相应测量平均值。

*   最后一行的`nan`代表而不是数字。

现在绘制了一个表示存储在数据库中的值的图形:

```sh
****`>` rrdtool graph free_mem.png \
--start 1272974830 \
--end 1272974871 \
--step=4 \
DEF:free_memory=free_mem.rrd:memory:AVERAGE \
LINE2:free_memory#FF0000 \
--vertical-label "GB" \
--title "Free System Memory in Time" \
--zoom 1.5 \
--x-grid SECOND:1:SECOND:4:SECOND:10:0:%X****
```

###### ****点注意事项****

*   `free_mem.png`是要创建的图形的文件名。

*   `--start`和`--end`限制图形绘制的时间范围。

*  `--step`指定图形的时间分辨率(秒)。

*   `DEF:...`部分是一个名为 *free_memory* 的数据定义。它的数据是从`free_mem.rrd`数据库中读取的，它的数据源叫做 *内存* 。计算 *平均值* 值点，因为在[部分 2.11.2.2 的“创建数据库”](cha-util.html#sec-util-rrdtool-example-create "2.11.2.2. Creating the database")中没有定义其他值点。****

*   `LINE...`部分指定了要绘制到图形中的线条的属性。它是 2 像素宽，它的数据来自*free _ memory*definition，它的颜色是红色。

*   `--vertical-label`设置沿 *y* 轴打印的标签，`--title`设置整个图形的主标签。

*   `--zoom`指定图形的缩放因子。该值必须大于零。

*   `--x-grid`指定如何将网格线及其标签绘制到图形中。我们的示例每秒放置一次，而主网格线每 4 秒放置一次。标签每隔 10 秒放置在主网格线下。

###### 图 2.1: 用 RRDtool 创建的示例图

### 2.11.3 更多信息

RRDtool 是一个非常复杂的工具，有很多子命令和命令行选项。有些很容易理解，但要让它产生你想要的结果，并根据你的喜好进行微调，可能需要付出很多努力。

除了只提供基本信息的 RRDtool 手册页(`man 1 rrdtool`)之外，您应该看看 [RRDtool 主页](https://oss.oetiker.ch/rrdtool/)。有一份详细的`rrdtool`命令及其所有子命令的[文档](https://oss.oetiker.ch/rrdtool/doc/index.en.html)。还有几个[教程](https://oss.oetiker.ch/rrdtool/tut/index.en.html)帮助你理解常见的 RRDtool 工作流程。

*如果你对监控网络流量感兴趣，看看 [MRTG(多路由器流量图示器)](https://oss.oetiker.ch/mrtg/)。MRTG 可以绘制许多网络设备的活动。它可以使用 RRDtool。